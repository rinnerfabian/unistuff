{\rtf1\ansi\deff3\adeflang1025
{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\froman\fprq2\fcharset2 Symbol;}{\f2\fswiss\fprq2\fcharset0 Arial;}{\f3\froman\fprq2\fcharset0 Liberation Serif{\*\falt Times New Roman};}{\f4\froman\fprq2\fcharset0 Liberation Sans{\*\falt Arial};}{\f5\froman\fprq2\fcharset0 Calibri;}{\f6\fnil\fprq2\fcharset0 Calibri;}{\f7\fnil\fprq2\fcharset0 Times New Roman;}{\f8\fnil\fprq0\fcharset128 Mangal;}{\f9\fnil\fprq2\fcharset0 Liberation Serif{\*\falt Times New Roman};}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet{\s0\snext0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033 Normal;}
{\*\cs15\snext15 Default Paragraph Font;}
{\*\cs16\snext16 Nummerierungszeichen;}
{\s17\sbasedon0\snext18\ql\nowidctlpar\hyphpar0\faauto\sb240\sa120\keepn\ltrpar\cf1\kerning1\dbch\af7\langfe1031\dbch\af9\afs28\alang1081\loch\f4\fs28\lang1033 \u220\'dcberschrift;}
{\s18\sbasedon0\snext18\sl276\slmult1\ql\nowidctlpar\hyphpar0\faauto\sb0\sa140\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033 Textk\u246\'f6rper;}
{\s19\sbasedon23\snext19\sl276\slmult1\ql\nowidctlpar\hyphpar0\faauto\sb0\sa140\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033 Liste;}
{\s20\sbasedon0\snext20\ql\nowidctlpar\hyphpar0\faauto\sb120\sa120\noline\ltrpar\cf1\i\kerning1\dbch\af6\langfe1031\dbch\af8\afs24\alang1081\ai\loch\f3\fs24\lang1033 Beschriftung;}
{\s21\sbasedon0\snext21\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033 Verzeichnis;}
{\s22\snext22\sl252\slmult1\ql\widctlpar\hyphpar0\faauto\sb0\sa160\ltrpar\cf1\kerning1\dbch\af7\langfe1031\dbch\af9\afs22\alang1081\loch\f5\fs22\lang1031 DocumentMap;}
{\s23\sbasedon0\snext23\sl276\slmult1\ql\nowidctlpar\hyphpar0\faauto\sb0\sa140\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033 Text Body;}
{\s24\sbasedon0\snext24\ql\nowidctlpar\hyphpar0\faauto\sb120\sa120\ltrpar\cf1\i\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\ai\loch\f3\fs24\lang1033 caption;}
}{\*\generator LibreOffice/6.1.4.2$Windows_X86_64 LibreOffice_project/9d0f32d1f0b509096fd65e0d4bec26ddd1938fd3}{\info{\creatim\yr2019\mo1\dy27\hr13\min58}{\revtim\yr2019\mo1\dy28\hr11\min46}{\printim\yr0\mo0\dy0\hr0\min0}}{\*\userprops{\propname Operator}\proptype30{\staticval ga48gov}}\deftab720\deftab720
\hyphauto0\viewscale170
{\*\pgdsctbl
{\pgdsc0\pgdscuse451\pgwsxn12240\pghsxn15840\marglsxn1800\margrsxn1800\margtsxn1440\margbsxn1440\pgdscnxt0 Standard;}
{\pgdsc1\pgdscuse451\pgndec\pgwsxn12240\pghsxn15840\marglsxn1800\margrsxn1800\margtsxn1440\margbsxn1440\pgdscnxt0 Erste Seite;}}
\formshade\paperh15840\paperw12240\margl1800\margr1800\margt1440\margb1440\sectd\sbknone\sectunlocked1\pgndec\pgwsxn12240\pghsxn15840\marglsxn1800\margrsxn1800\margtsxn1440\margbsxn1440\ftnbj\ftnstart1\ftnrstcont\ftnnar\aenddoc\aftnrstcont\aftnstart1\aftnnrlc
{\*\ftnsep\chftnsep}\pgndec\pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\ul\ulc0\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
01-IoT \u8211\'96 Praktikum:GRE}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Hallo uns}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
e}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
r}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
 Team }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
hat sich i}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
n den letzten Monaten mit der AVR-Architektur und mit dem \u220\'dcbertragungsmodul CC1101 }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
befasst}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\ul\ulc0\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
02-Der Start\u8230\'85:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Wir drei wohnen alle in derselben Wohnung deshalb haben wir die meiste Zeit zusammen am Projekt gearbeitet. Alle drei hatten am Anfang gar keine Vorkenntnisse \u252\'fcber die AVR-Technologie }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
und \u252\'fcber die Programmiersprache C}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
. Um ein besseres Verst\u228\'e4ndnis zu erlangen haben wir uns ein Elegoo Uno Startet-Kit gekauft, um uns mit allem bekannt zu machen. Das dabei enthaltene Elegoo Uno-Board unterscheidet sich in so gut wie nichts zu einem Arduino Uno. Das Starter-Kit beinhaltet neben dem Elegoo unterschiedlichste Sensoren }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
wie z.B. Bewegungssenore, Fernbedienung.. aber auch verschiedene Motoren.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
In den ersten Wochen arbeiteten wir mit vielen Sensoren, um die Grundprinzipe der Programmierung und der Elektronik eines }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Mikrocontrollers}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
 besser zu verstehen.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\ul\ulc0\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
03-Einparksensor:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Eines unserer Arduino Projekte war ein Einparksensor. Dazu verwendeten wir einen aktiven Buzzer und einen Ultraschallsensor.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Ein aktiver Buzzer kann nur eine Tonfrequenz ausgeben und wird somit nur mit HIGH oder LOW betrieben. Im Gegensatz zum Aktiven gibt es auch einen passiven Buzzer, dieser kann \u252\'fcber die analogen Ausg\u228\'e4nge des Arduinos verschiedene T\u246\'f6ne von sich geben.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Der Ultraschallsensor misst den Abstand zum n\u228\'e4chsten Objekt bis zu einer Distanz von }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
2 bis maximal 5}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
 Metern. Dieses haben wir nun mit dem aktiven Buzzer verbunden.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Auf der Folie sehen wir den Arduino Code f\u252\'fcr dieses Projekt. Als erstes wurde die Library f\u252\'fcr den Ultraschallsensor importiert und ein Objekt davon erzeugt. Der Buzzer wurde an Pin 9 angeschlossen und als Output definiert. Durch den Aufruf der Methode \u8222\'84Distance()\u8220\'93 erh\u228\'e4lt man die Distanz in cm. Je nach Abstand gibt der Buzzer ein Signal von sich, dass umso schneller sich wiederholt je n\u228\'e4her sich das gemessene Objekt befindet.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\ul\ulc0\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
04-Idee:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Nach den Projekten mit dem }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Arduino}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
 \u252\'fcberlegten wir nun was sich am besten f\u252\'fcr eine \u220\'dcbertragung an eine Station eignet. Wir entschieden uns f\u252\'fcr eine Wetterstation, die wir auch je nach Schnelligkeit des Fortschritts im Laufe des Projekts noch durch }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
einen weiteren}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
 Sensor erweitern k\u246\'f6nnen. F\u252\'fcr den Anfang sollte unsere Wetterstation die Temperatur und die Luftfeuchtigkeit messen. Dazu verwenden wir einen DHT11-Sensor:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Mit dem DHT11 Sensor ist es m\u246\'f6glich Temperaturen von 0-50\u176\'b0C und Luftfeuchtigkeit von 20-90% zu messen. Der Sensor verwendet ein single-wire serial interface und ist somit leicht und schnell zu programmieren. Der DHT ist klein und verbraucht nur wenig Strom.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Mit dem }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Arduino}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
 hatten wir den Temperatursensor bald am Laufen, da wir eigentlich nur die geeignete Bibliothek und den Sketch einbinden und ausf\u252\'fchren mussten.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\dbch\af6\dbch\af6\rtlch \ltrch\loch\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Nachdem der Temperatursensor }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
mit unserem Arduino }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
funktionierte wollten wir nun auch mit dem CC1101 arbeiten. Wir fanden eine dazu eine Bibliothek im Internet. Zus\u228\'e4tzlich zu der Bibliothek kopierter wir zwei verschiedene Sketches, einmal f\u252\'fcr das Ger\u228\'e4t das sendet und einmal f\u252\'fcr das Ger\u228\'e4t das die Daten empfangen soll. Die \u220\'dcbertragung mit der gefundenen Bibliothek und Sketches testeten wir im Praktikumsraum mit dem Arduino und dem CC1101-Modul dort. Das \u220\'dcbertragen von Daten gelang uns auf Anhieb.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0{\ul\ulc0\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
05-Atmel ATmega 328p:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Nachdem wir auf dem }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Ardiuno}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
 }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
den Temperatursensor und den CC1101}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
 getestet haben, wollten wir mit dem Bau unseres eigenen Boards starten. Wir haben uns f\u252\'fcr einen AVR-Microcontroller entschieden. Die AVR-Microcontroller sind ausgelegt, um effizienten }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
C-Code auszuf\u252\'fchren}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
. Die AVR Familie wird haupts\u228\'e4chlich in drei Typen klassifiziert: tinyAVR, megaAVR und XMEGA welche sich lediglich in der Leistungsf\u228\'e4higkeit und }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
ein wenig in der }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
 Funktionalit\u228\'e4t unterscheiden. Das naheliegendste bei der Auswahl des Microcontrollers war es den gleichen Chip wie auf dem Arduino Uno, also den Atmega328p zu verwenden.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Der Atmel ATmega328p ist ein 8-bit AVR-Microkontroller, welcher mit einer Spannung von zwischen 1,8 bis 5,5 Volt und bis zu einer maximalen Taktrate bis zu 20MegaHerz arbeitet.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Die Atmega Chips haben immer das gleiche Schema in der Namensgebung z.B. bei Atmega 328p}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
1. Die Baureihe (hier Atmega)}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
2. Eine Nummer (immer Zweierpotenz), welche die Gr\u246\'f6\u223\'dfe des Flash-Speichers angibt. Also in }{\uldb\ulc0\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
unserem}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
 Beispiel sind das 32 KiB}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
3. Nach dem Flash-Speicher k\u246\'f6nnen bis zu drei weitere Ziffern folgen. Diese definieren die Baureihe, die Anzahl der I/O Pins und Zusatzfunktionen an. Bei unserem Chip haben wir nur eine Ziffer, die 8. Wir haben hier die neuste Baureihe von 4 bis 32 KiB Flash-Speicher, ein mit 28 \u8211\'96 32 pinkompatibel Geh\u228\'e4use und verbesserte Funktionen, wie z.B. Timern. Mit ihrer Hilfe ist es m\u246\'f6glich, in regelm\u228\'e4\u223\'dfigen Zeitabst\u228\'e4nden Aktionen zu veranlassen.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
4. An vierter Stelle kommen bis zu zwei Buchstaben, die f\u252\'fcr die Revision und spezielle stromsparende Architektur stehen. Das P steht f\u252\'fcr Pico-Power. Es erlaubt den Mikrocontroller mit einer niedrigeren Volt Anforderungen zu arbeiten}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\ulnone\ulc0\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
5. Zuletzt kommt ein Bindestrich und bis zu zwei weiteren Buchstaben, die die Bauform angeben. PU steht f\u252\'fcr ein bleifreies DIP-Geh\u228\'e4use (Dual in-line package \u8594\'3f l\u228\'e4ngliches Geh\u228\'e4use)}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\ul\ulc0\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
06-Vom Arduino zum Standalone:PAT}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Als erstes, haben wir im Internet nach einer Anleitung gesucht, um den Chip aus dem Arduino zu nehmen, und ihn auf einem Breadboard laufen zu lassen. Auf der Arduino Website fanden wir ein Tutorial, wie man den Chip nur mit Hilfe eines Arduino Boards programmieren kann. Daf\u252\'fcr sollte man den Chip vom Arduino nehmen und ihn auf ein Breadboard stecken.}{\rtlch \ltrch\loch
\line }{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Im Falle eines leeren Chips musste man als ersten Schritt den Arduino Bootloader auf den Chip laden, aber das mussten wir nicht tun, da wir den Arduino-Chip verwendeten. Der n\u228\'e4chste Schritt war das Board ans Arduino anzuschlie\u223\'dfen. Einfach Volt und Ground verbinden, den Reset vom Arduino und VCC mit einem 10k Widerstand an den Reset Port des Chips anschlie\u223\'dfen und noch den TX vom Arduino an den RX vom Chip und andersrum anstecken. Wo sich diese Ports alle befinden, lie\u223\'df sich leicht aus dem Datasheet des Chips herauslesen.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
In der Arduino IDE mussten wir Port und das richtige Board ausw\u228\'e4hlen, um den ersten Blink Sketch hochzuladen. Aber das hat bei uns, auch nach l\u228\'e4ngerer Fehlersuche nicht funktioniert. Deshalb suchten wir im Internet nach weiteren Anleitungen, um den Chip auch ohne Arduino zum Laufen zu bringen. Aber bei den meisten Tutorials ben\u246\'f6tigte man einen 16MHZ Crystal, den wir aber nicht besa\u223\'dfen und wir auch im Praktikumsraum keinen finden konnten.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\ul\ulc0\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
07-Pololu AVR-Programmer:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Das Problem jetzt war, dass wir einen Programmer brauchten, um den Chip zu programmieren, weil nun nicht mehr das Arduino als Programmer herhalten konnte. Im Praktikumsraum fanden wir dazu mehrere Pololu Avr Programmer. Der Pololu USB AVR-Programmer ist ein kompakter ISP (In-System Programmer) f\u252\'fcr AVR Mikrocontroller. Der Programmer stellt ein Interface zur \u220\'dcbertragung eines kompilierten AVR Programms vom PC zum Flash Speicher des Chips zur Verf\u252\'fcgung. Nach schlau machen auf deren Seite, haben wir den Programmer an unserem Microcontroller angeschlossen.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\ul\ulc0\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
08-Atmel Studio und Tera Term:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Neben Programmer verwendeten wir ab jetzt nun auch nicht mehr die Arduino IDE sondern suchten nach einer passenden Entwicklungsumgebung. Nach k\u252\'fcrzeren Recherchen wurde uns Atmel Studio (ehemaliges AVR Studio) f\u252\'fcr Windows empfohlen und so entschieden wir uns f\u252\'fcr diese IDE. Bevor man mit Atmel Studio programmieren kann, muss man noch ein paar Anwendungen installieren. Dazu z\u228\'e4hlt WinAVR. WinAVR enth\u228\'e4lt neben dem C und C++ Compiler f\u252\'fcr alle AVR Mikrocontroller und den erforderlichen Zusatzprogrammen, den sogenannten Binutils, noch einige andere Pakete, z. B. die Bibliotheken avr-libc oder avr-io, die Programmiersoftware AVRDUDE und den Editor Programmer's Notepad.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Atmel Studio besitzt leider keinen wirklich brauchbaren Seriellen Monitor, deshalb installierten wir uns die Software \u8220\'93Tera Term\u8221\'94 mit der wir die Ausgaben kontrollieren konnten. Tera Term ist ein kostenloser Terminal-Emulator, der einfach einzurichten ist. Beim starten des Terminals kann man den Port ausw\u228\'e4hlen, dessen Ausgaben man anzeigen lassen will. Da der Pololu Programmer zwei Ports besitzt, konnten wir einen zum Programmieren und den anderen als Schnittstelle f\u252\'fcr unseren seriellen Monitor benutzen.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Wir dachten, dass unser Microcontroller da er ja durch dem Programmer mit Strom und Ground angeschlossen mit Strom versorgt w\u228\'e4re. Allerdings leuchtete die rote LED auf dem Pololu immer noch rot und wir gelangen nicht in den Programming-Mode.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Wir mussten uns daher um eine externe Stromversorgung k\u252\'fcmmern. Die meiste Zeit arbeiteten wir zu Hause und konnten so nicht die Ger\u228\'e4te im Praktikumsraum verwenden. Anstelle verwendeten wir den Elegoo Power MB v2 der auch bei dem Starter Kit mitgeliefert wurde. Mit diesem waren wir nun in Stande unseren Microcontroller mit 3,3 oder 5 Volt zu versorgen. Manchmal verwendeten wir auch das Elegoo Uno Board zur reinen Stromversorgung.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Nun haben wir alles angeschlossen und konnten unser erstes C++ Programm auf den Chip laden. Wie beim Arduino war das ein einfacher Blink Sketch.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\lang1031

\par \sect\sectd\sectunlocked1\pgwsxn12240\pghsxn15840\marglsxn1800\margrsxn1800\margtsxn1440\margbsxn1440\ltrsect\sbknone\pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\ul\ulc0\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
09-BlinkSketch:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Hier auf der Folie sieht man den Code f\u252\'fcr den Sketch, mit dem wir eine LED zum Blinken bringen wollen. Im Gegensatz zum Arduino sieht es jetzt schon deutlich komplizierter aus. Da wir kein Arduino Framework zum Programmieren verwenden, konnten wir Methoden wie pinMode, digitalRead oder digitalWrite nicht verwenden. Deshalb haben wir eine Header Datei erstellt, welche wir importieren, in der wir die 3 Methoden selbst geschrieben haben und die Arduino Methoden ersetzen.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar\ul\ulc0\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\ul\ulc0\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
10-13-pinMode, usw.:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Auf diese m\u246\'f6chte ich jetzt kurz eingehen.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Mit der Methode PinMode kann man einen Pin als OUTPUT oder INPUT definieren. Um einen Pin als INPUT/OUTPUT zu definieren, muss man diesen im zust\u228\'e4ndigen Register eintragen. DDRD verwendet man f\u252\'fcr die Ports D, DDRB f\u252\'fcr die Ports B. Um jetzt den Port D4 als Output einzutragen, schreibt man DDRD |= (1<<4). Um das jetzt erkl\u228\'e4ren, nehmen wir an, dass das Register DDRD so aussieht. Der Ausdruck 1<<4 ist ein leftshift um 4 stellen. Als Startwert nehmen wir 00000001 und verschieben alle Bits um vier Stellen nach Links.  Damit erhalten wir 00010000. Diese Bitfolge verkn\u252\'fcpft man mit dem \u8220\'93oder\u8221\'94 Operator und man erh\u228\'e4lt diesen Ausdruck. Das vierte Bit ist nun eine 1, also ein Output. }
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
So ziemlich \u228\'e4hnlich sieht es aus, wenn man einen Port als INPUT definieren m\u246\'f6chte. Der Unterschied zwischen den 2 ist, dass man nun, nach dem leftshift, alle Bits negieren muss, und dann nicht mit einem Oder verkn\u252\'fcpfen, sondern mit einem Und Operator. Bei diesem Beispiel hier m\u246\'f6chte ich den Port2 als Input definieren. Wie man auf der Folie sehen kann, ist das zweite Bit nun eine 0, also ein Input.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Die Methode digitalWrite ben\u246\'f6tigt einen Pin und den Parameter High oder Low. Der Ausdruck f\u252\'fcr High ist derselbe wie der, den man verwendet, wenn man einen Port als OUT bzw INPUT definieren will. Der Unterschied zur PinMode liegt darin, dass man nun das Port Register verwenden muss, anstatt des DDRD. Das Gleiche gilt f\u252\'fcr LOW. }
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
DigitalRead bekommt als Parameter nur den Pin. Um zu \u252\'fcberpr\u252\'fcfen, ob der Input von Port 4 High ist, muss der Ausdruck PIND & (1<<4) true ergeben. F\u252\'fcr Low logischerweise false. Zum Code. Nehmen wir an, PORT 4 ist HIGH. PIND besteht zum Beispiel aus der folgenden Bitfolge. Der leftshift ist wieder derselbe wie bei den Beispielen vorher. Nach dem Anwenden des Und Operators erhalten wir eine Bitfolge, die nicht 0 ergibt, also High. In unserem Beispiel haben wir 16 erhalten. Sollte der Port4 LOW sein, dann w\u252\'fcrden wir 0 herausbekommen.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\ul\ulc0\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
14-Fehlerbehebung:FAB}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Der LED-Sketch funktionierte. Der n\u228\'e4chste Schritt war nun den Temperatursensor auch auf unserem Standalone-MCU zum Laufen zu bringen.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
In erster Linie verwendeten wir den gleichen Code wir vorher bei dem Arduino. Das hei\u223\'dft wir importierten dieselbe Library und kopierten auch den Code von der Main-Datei. Den Temperatursensor zum Laufen zu bringen brachte jedoch in Hinblick auf die anderen Sketches zuvor mehrere Schwierigkeiten. Beim Compilieren des Codes traten viele Fehler auf. Da die Library f\u252\'fcr Arduino bestimmt war, mussten wir noch ein paar Dinge anpassen. Zum Beispiel mussten wir den Datentyp Byte, den Arduino verwendet, selber hinzuf\u252\'fcgen. F\u252\'fcr pinMode, digitalRead und digitalWrite haben wir unsere Methoden, wie vorher angesprochen, verwendet und wir mussten zus\u228\'e4tzlich eine Library f\u252\'fcr Strings einbinden, sodass es m\u246\'f6glich war, den Code erfolgreich zu builden. Nach den Basteleien traten keine Fehler bei der Compilierung des Codes mehr auf. Beim hochladen auf den Chip allerdings funktionierte der Temperatursensor immer noch nicht. Den Wert, den der Sensor uns zuschickt, haben wir in Tera Term ausgeben lassen. Aber anstatt des Wertes f\u252\'fcr die Temperatur/Luftfeuchtigkeit, wurden nur wei\u223\'dfe K\u228\'e4stchen ausgegeben. Der einzige Grund f\u252\'fcr den Fehler lag nach unserer Meinung an dem Takt des Chips.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Wir haben uns entschlossen, statt dem internen Oszillator des Microcontrollers, der eine Taktrate von bis zu 8Mhz erreichen kann, auf einen externen Quarz mit denselben Mhz wie dem Arduino, also 16Mhz, umzusteigen. Zwar wird in mehreren Foren erw\u228\'e4hnt, dass f\u252\'fcr Sensoren wie einem Temperatur-Sensor der interne Oszillator leicht ausreichen m\u252\'fcsste, aber wir versuchten es trotzdem.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Nach dem Einbauen des 16Mhz Quarz und dem Einstellen der Fuse-Bits bei den Programmer-Einstellungen lief nun auch der DHT11-Temperatursensor ohne Probleme, ohne den Code von vorher ver\u228\'e4ndert zu haben. Zu diesem Zeitpunkt konnten wir es uns noch nicht erkl\u228\'e4ren wieso es mit der internen Taktrate des Microcontrollers nicht funktioniert hat.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Durch den externen Quarz muss der Microcontroller f\u252\'fcr ein sichergestelltes Laufen mit ca. 5 Volt versorgt werden und durch die erh\u246\'f6hte Taktzahl steigt der Stromverbrauch. Wir versuchten somit nochmals unseren Sensor auch ohne externen Oszillator zum Laufen zu bringen.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Wir fanden eher durch Gl\u252\'fcck den Fehler, denn schlussendlich lag das Problem an der Definition des F_CPUs. Wir haben ihn mit einer Geschwindigkeit von 8.000.000UL definiert, weil auch die meisten Codebeispielen im Internet UL f\u252\'fcr (Unsigned Long) hinzugef\u252\'fcgt hatten und wir eigentlich nicht daran dachten, dass das einen Unterschied machen w\u252\'fcrde. Eher durch Zufall l\u246\'f6schten wir die K\u252\'fcrzel UL weck und es funktionierte endlich auch ohne externen Quarz und aus den mysteri\u246\'f6sen K\u228\'e4stchen wurde Temperatur und Luftfeuchtigkeit.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\sl276\slmult1\li0\ri0\lin0\rin0\fi0\ltrpar{\ul\ulc0\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
15-Temperatur- und Luftfeuchtigkeitssensor:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Nun genauere Informationen zu unserem Temperatur- und Luftfeuchtigkeitssensor:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Der DHT11 Sensor kann mit 3,3 \u8211\'96 5.5VDC versorgt werden. Bei unserem Microcontroller verwenden wir f\u252\'fcr die Versorgung eine Spannung von 3,3 Volt.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Ein Kommunikationsprozess zwischen MCU und Sensor dauert in etwa 4 ms.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
F\u252\'fcr die Kommunikation und die Synchronisation zwischen dem MCU und dem Temperatursensor wird das Single-bus data format verwendet. Das hei\u223\'dft zur \u220\'dcbertragung dient allein 1 Kabel \u8211\'96 one-wire.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Der Kommunikations-Prozess gestaltet sich wie folgt: Zu Beginn schickt der Microcontroller ein Start-Signal an den Sensor. Daraufhin schaltet der Sensor in den running-mode. Nun antwortet der Sensor mit einem Signal von 40-bit Daten und sobald die Daten \u252\'fcbermittelt wurden geht der Sensor wieder in den low-power-consumption mode \u252\'fcber.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\ul\ulc0\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
16-Kommunikationsprozess:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Hier noch mal genauer:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Man sieht in dieser Abbildung noch einmal gut, dass der Single-Bus sowohl von MCU als auch vom Sensor verwendet wird und sich die Verwendung je nach Fortschreiten des Prozesses ver\u228\'e4ndert.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Unser Programm setzt den Data Single-bus von high auf low, dieser Vorgang muss eine bestimmte Zeit dauern, sodass der Sensor unser Start-Signal erh\u228\'e4lt. Nun k\u246\'f6nnen wir den Bus wieder auf high setzen und warten auf die Antwort des DHT.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Sobald der Sensor das Start Signal erhalten hat passieren noch einige Start-Prozeduren. Wir k\u246\'f6nnen dadurch nochmals feststellen ob f\u252\'fcr die \u220\'dcbertragung der Daten alles funktioniert, ansonsten wird die \u220\'dcbertragung abgebrochen und ein Fehler zur\u252\'fcckgegeben. Sind diese Prozeduren erfolgreich abgeschlossen beginnt nun der eigentliche Datenaustausch.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\ul\ulc0\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
17-Bit-\u220\'dcbertragung:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Jedes Bit wird folgenderma\u223\'dfen \u252\'fcbertragen:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Der Sensor beginnt mit einem 50us low-voltage-level.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Die confirm-Methode, die wir hier sehen, wird immer dann verwendet, wenn eine \u220\'dcbertragung vom Sensor stattfindet, um zu \u252\'fcberpr\u252\'fcfen ob sie rechtm\u228\'e4\u223\'dfig, wie von uns erwartet, abgelaufen ist. Im Laufe des Programms gibt es 6 Stellen wo bei Fehlern abgebrochen wird, um genauer zu identifizieren wo der Fehler aufgetreten ist. Das sieht man z.B: hier oder hier. Die uns bei unserem Problem, aber trotzdem nicht weiter helfen konnten.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Die L\u228\'e4nge des darauffolgende high-voltage-level bestimmt dann den Wert 1 oder 0. Dauert das Signal zwischen 26-28us dann \u252\'fcbertr\u228\'e4gt der Sensor eine \u8220\'930\u8221\'94, hat das Signal eine L\u228\'e4nge von 70us \u252\'fcbertr\u228\'e4gt er eine \u8220\'931\u8221\'94. Diese us werden hier in der for-Schleife gez\u228\'e4hlt mit Hilfe von ticks zu je 10 us. Waren es \u252\'fcber 3 ticks, also eine 1, sind es weniger als 3 ticks eine 0.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Ist das 40. und letzte Bit \u252\'fcbertragen folgt ein pull down des voltage level f\u252\'fcr 50us. Danach geht der Single-Bus voltage zur\u252\'fcck in den free status.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\ul\ulc0\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
18-parse-Methode:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Nach der \u220\'dcbertragung der 40 Bits m\u252\'fcssen diese nat\u252\'fcrlich noch richtig geparsed werden, sodass sie auch im richtigen Format ausgegeben werden k\u246\'f6nnen, darauf gehen wir aber jetzt nicht genauer ein.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Hier noch ein kurzer Einblick auf die zuvor angesprochene Checksumme. Alle Teil-Bytes werden addiert und \u252\'fcberpr\u252\'fcft ob sie mit dem letzten Byte \u252\'fcbereinstimmen. Ist das der Fall, dann kann Temperatur und Luftfeuchtigkeit ausgegeben werden, ist das nicht so, dann hat sich ein \u220\'dcbertragungsfehler ereignet und die \u220\'dcbertragung war wertlos und muss wiederholt werden.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Da nun der Temperatur-Sensor verl\u228\'e4sslich arbeitet, haben wir uns wieder unserer \u220\'dcbertragungstechnologie, dem CC1101, gewidmet. Zum Schluss gelang uns dort noch eine Kommunikation mit unserem Standalone Microcontroller und dem Arduino, wie am Anfang von Arduino zu Arduino. Allerdings erhielt der Arduino nicht die richtigen Daten sondern wieder nur undefinierte K\u228\'e4stchen. An diesem Problem werden wir nach der Klausurenpause als erster weiter arbeitet.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\ul\ulc0\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Zum Abschluss ist zu sagen:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Das Projekt bis jetzt hat uns allen drei sehr gut gefallen auch wenn es immer wieder zu frustrierenden Phasen gekommen ist. Uns fehlt es einfach an Grundverst\u228\'e4ndnis bei diesen ganzen Sachen, vor allem bei Hardware bezogenen Dingen, aber auch bei der Entwicklung mit C und bei gewissen Grundeinstellungen, die vorgenommen werden m\u252\'fcssen bis der Microcontroller \u252\'fcberhaupt l\u228\'e4uft. Daher haben wir immer wieder ziemlich viel Zeit in das Projekt investiert, ohne gro\u223\'dfe Fortschritte zu machen. Weil jedes Mal beim Auftreten von kleinen Fehlern konnten wir diese nicht sofort beheben. Das Programmieren des Microcontrollers an sich fanden wir weniger schwierig.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Wir haben in diesem Praktikum bis jetzt alle ziemlich viel dazugelernt und unsere Kenntnisse in diesem Bereich erweitert.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\ul\ulc0\dbch\af7\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
GRE:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Aktuell sieht unser Mi}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
k}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
ro}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
c}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
ontroller wie folgt aus }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
ohne den Pololu avr Programmer und den }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
T}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
ransceiver  CC1101}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
:}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Links das vor\u252\'fcbergehend verbaute Netzteil }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
E}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
legoo mb v2 f\u252\'fcr unsere Stromversorgung. }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
An dieses  Netzteil kann entweder eine Batterie oder einen Kabel zur Steckdose angeschlossen werden. Wir}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
 versorgen den Mikrocontroller mit 3,3 Volt. }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
An unsere Chip}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
 haben }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
wir }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
einen Resetbutton an den RESET-Pin hinzugef\u252\'fcgt und }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
hier recht ist}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
 unser Temperatur und Luftfeuchtigkeit  Sensor }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
welcher mit Pin 3 verbunden ist.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Der DHT11-Sensor funktioniert nun, vielleicht werden wir unsere Wetterstation um einen weiteren Sensor erweitern }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
wie z.B. einen Luftdrucksensor oder Luftqualit\u228\'e4tssensor}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
.}
\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Nat\u252\'fcrlich m\u252\'fcssen wir als n\u228\'e4chstes das Transceiver Modul fertigstellen und Details mit dem Station-Team besprechen um herauszufinden was dann die n\u228\'e4chsten Schritte sein werden. Zus\u228\'e4tzlich muss noch gekl\u228\'e4rt werden wie unsere Stromversorgung aussieht und wie wir sie gestalten werden.  }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Und zum Schluss muss n}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
o}{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
ch alles auf die Platine. }{\dbch\af6\dbch\af6\rtlch \ltrch\loch\fs22\lang1031\loch\f5\hich\af5
Aber das werden wir nach der Klausurenpause kl\u228\'e4ren. Der Entwurf f\u252\'fcr die Platine sieht bis zum jetzigen Zeitpunkt wie folgt aus:}
\par \sect\sectd\sectunlocked1\pgwsxn12240\pghsxn15840\marglsxn1800\margrsxn1800\margtsxn1440\margbsxn1440\ltrsect\sbknone\pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar\dbch\af7\rtlch \ltrch\loch\lang1031

\par \pard\plain \s0\ql\nowidctlpar\hyphpar0\faauto\ltrpar\cf1\kerning1\dbch\af6\langfe1031\dbch\af9\afs24\alang1081\loch\f3\fs24\lang1033\li0\ri0\lin0\rin0\fi0\ltrpar\rtlch \ltrch\loch

\par \sect\sectd\sectunlocked1\pgwsxn12240\pghsxn15840\marglsxn1800\margrsxn1800\margtsxn1440\margbsxn1440\pgndec\sbknone}