{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031\deflangfe1031{\fonttbl{\f0\fswiss\fprq2\fcharset0 Calibri;}{\f1\fnil\fcharset1 Cambria Math;}}
{\colortbl ;\red0\green0\blue0;}
{\*\generator Riched20 10.0.17134}{\*\mmathPr\mmathFont1\mnaryLim0\mdispDef1\mwrapIndent1440 }\viewkind4\uc1 
\pard\nowidctlpar\hyphpar0\cf1\kerning1\ul\f0\fs22 01-IoT \endash  Praktikum:GRE\ulnone\fs24\par
\fs22 Sehr geehrte Kommilitonen \'85. Unser Team befasste sich in den letzten Monaten mit der AVR-Architektur und mit dem \'dcbertragungsmodul CC1101 vom Hersteller Texas Instruments.\fs24\par
\fs22\par
\ul 02-Der Start\'85:\ulnone\fs24\par
\fs22 Wir drei wohnen alle in derselben Wohnung deshalb haben wir die meiste Zeit zusammen am Projekt gearbeitet. Alle drei hatten am Anfang gar keine Vorkenntnisse \'fcber die AVR-Technologie. Um ein besseres Verst\'e4ndnis zu erlangen haben wir uns ein Elegoo Uno Startet-Kit gekauft, um uns mit allem bekannt zu machen. Das dabei enthaltene Elegoo Uno-Board unterscheidet sich in so gut wie nichts zu einem Arduino Uno. Das Starter-Kit beinhaltet neben dem Elegoo unterschiedlichste Sensoren.\fs24\par
\fs22\par
In den ersten Wochen arbeiteten wir mit vielen Sensoren, um die Grundprinzipe der Programmierung und der Elektronik eines Microcontrollers besser zu verstehen.\fs24\par
\fs22\par
\ul 03-Einparksensor:\ulnone\fs24\par
\fs22 Eines unserer Arduino Projekte war ein Einparksensor. Dazu verwendeten wir einen aktiven Buzzer und einen Ultraschallsensor.\par
Ein aktiver Buzzer kann nur eine Tonfrequenz ausgeben und wird somit nur mit HIGH oder LOW betrieben. Im Gegensatz zum Aktiven gibt es auch einen passiven Buzzer, dieser kann \'fcber die analogen Ausg\'e4nge des Arduinos verschiedene T\'f6ne von sich geben.\par
Der Ultraschallsensor misst den Abstand zum n\'e4chsten Objekt bis zu einer Distanz von maximal 2,5 Metern. Dieses haben wir nun mit dem aktiven Buzzer verbunden.\par
Auf der Folie sehen wir den Arduino Code f\'fcr dieses Projekt. Als erstes wurde die Library f\'fcr den Ultraschallsensor importiert und ein Objekt davon erzeugt. Der Buzzer wurde an Pin 9 angeschlossen und als Output definiert. Durch den Aufruf der Methode \'84Distance()\ldblquote  erh\'e4lt man die Distanz in cm. Je nach Abstand gibt der Buzzer ein Signal von sich, dass umso schneller sich wiederholt je n\'e4her sich das gemessene Objekt befindet.\par
\par
\ul 04-Idee:\ulnone\fs24\par
\fs22 Nach den Projekten mit dem Elegoo \'fcberlegten wir nun was sich am besten f\'fcr eine \'dcbertragung an eine Station eignet. Wir entschieden uns f\'fcr eine Wetterstation, die wir auch je nach Schnelligkeit des Fortschritts im Laufe des Projekts noch durch weitere Sensoren erweitern k\'f6nnen. F\'fcr den Anfang sollte unsere Wetterstation die Temperatur und die Luftfeuchtigkeit messen. Dazu verwenden wir einen DHT11-Sensor:\par
Mit dem DHT11 Sensor ist es m\'f6glich Temperaturen von 0-50\'b0C und Luftfeuchtigkeit von 20-90% zu messen. Der Sensor verwendet ein single-wire serial interface und ist somit leicht und schnell zu programmieren. Der DHT ist klein und verbraucht nur wenig Strom.\par
Mit dem Elegoo hatten wir den Temperatursensor bald am Laufen, da wir eigentlich nur die geeignete Bibliothek und den Sketch einbinden und ausf\'fchren mussten.\par
\fs24\par
\fs22 Nachdem der Temperatursensor funktionierte wollten wir nun auch mit dem CC1101 arbeiten. Wir fanden eine dazu eine Bibliothek im Internet. Zus\'e4tzlich zu der Bibliothek kopierter wir zwei verschiedene Sketches, einmal f\'fcr das Ger\'e4t das sendet und einmal f\'fcr das Ger\'e4t das die Daten empfangen soll. Die \'dcbertragung mit der gefundenen Bibliothek und Sketches testeten wir im Praktikumsraum mit dem Arduino und dem CC1101-Modul dort. Das \'dcbertragen von Daten gelang uns auf Anhieb.\par
\par

\pard\nowidctlpar\hyphpar0\sl276\slmult1\ul 05-Atmel ATmega 328p:\par
\ulnone Nachdem wir auf dem Elegoo fast alle Sensoren, die beim Kit dabei waren, getestet haben, wollten wir mit dem Bau unseres eigenen Boards starten. Ich habe mich mit dem Aufbau des Boards besch\'e4ftigt. Wir haben uns f\'fcr einen AVR-Microcontroller entschieden. Die AVR-Microcontroller sind ausgelegt, um effizienten Ausf\'fchrung von C-Code zu gestalten. Die AVR Familie wird haupts\'e4chlich in drei Typen klassifiziert: tinyAVR, megaAVR und XMEGA welche sich lediglich in der Leistungsf\'e4higkeit und Funktionalit\'e4t unterscheiden. Das naheliegendste bei der Auswahl des Microcontrollers war es den gleichen Chip wie auf dem Arduino Uno, also den Atmega328p zu verwenden.\par
Der Atmel ATmega328p ist ein 8-bit AVR-Microkontroller, welcher mit einer Spannung von zwischen 1,8 bis 5,5 Volt und bis zu einer maximalen Taktrate bis zu 20MegaHerz arbeitet.\par
Die Atmega Chips haben immer das gleiche Schema in der Namensgebung z.B. bei Atmega 328p\fs24\par
\fs22 1. Die Baureihe (hier Atmega)\fs24\par

\pard\nowidctlpar\hyphpar0\fs22 2. Eine Nummer (immer Zweierpotenz), welche die Gr\'f6\'dfe des Flash-Speichers angibt. Also in \uldb unserem\ulnone  Beispiel sind das 32 KiB\fs24\par
\fs22 3. Nach dem Flash-Speicher k\'f6nnen bis zu drei weitere Ziffern folgen. Diese definieren die Baureihe, die Anzahl der I/O Pins und Zusatzfunktionen an. Bei unserem Chip haben wir nur eine Ziffer, die 8. Wir haben hier die neuste Baureihe von 4 bis 32 KiB Flash-Speicher, ein mit 28 \endash  32 pinkompatibel Geh\'e4use und verbesserte Funktionen, wie z.B. Timern. Mit ihrer Hilfe ist es m\'f6glich, in regelm\'e4\'dfigen Zeitabst\'e4nden Aktionen zu veranlassen.\fs24\par
\fs22 4. An vierter Stelle kommen bis zu zwei Buchstaben, die f\'fcr die Revision und spezielle stromsparende Architektur stehen. Das P steht f\'fcr Pico-Power. Es erlaubt den Mikrocontroller mit einer niedrigeren Volt Anforderungen zu arbeiten\fs24\par
\fs22 5. Zuletzt kommt ein Bindestrich und bis zu zwei weiteren Buchstaben, die die Bauform angeben. PU steht f\'fcr ein bleifreies DIP-Geh\'e4use (Dual in-line package \f1\u8594?\f0\lang1031  l\'e4ngliches Geh\'e4use)\par
\par
\ul 06-Vom Arduino zum Standalone:PAT\par
\ulnone Als erstes, haben wir im Internet nach einer Anleitung gesucht, um den Chip aus dem Arduino zu nehmen, und ihn auf einem Breadboard laufen zu lassen. Auf der Arduino Website fanden wir ein Tutorial, wie man den Chip nur mit Hilfe eines Arduino Boards programmieren kann. Daf\'fcr sollte man den Chip vom Arduino nehmen und ihn auf ein Breadboard stecken.\line Im Falle eines leeren Chips musste man als ersten Schritt den Arduino Bootloader auf den Chip laden, aber das mussten wir nicht tun, da wir den Arduino-Chip verwendeten. Der n\'e4chste Schritt war das Board ans Arduino anzuschlie\'dfen. Einfach Volt und Ground verbinden, den Reset vom Arduino und VCC mit einem 10k Widerstand an den Reset Port des Chips anschlie\'dfen und noch den TX vom Arduino an den RX vom Chip und andersrum anstecken. Wo sich diese Ports alle befinden, lie\'df sich leicht aus dem Datasheet des Chips herauslesen.\par

\pard\nowidctlpar\hyphpar0\sl276\slmult1\fs24\lang1033\par
\fs22\lang1031 In der Arduino IDE mussten wir Port und das richtige Board ausw\'e4hlen, um den ersten Blink Sketch hochzuladen. Aber das hat bei uns, auch nach l\'e4ngerer Fehlersuche nicht funktioniert. Deshalb suchten wir im Internet nach weiteren Anleitungen, um den Chip auch ohne Arduino zum Laufen zu bringen. Aber bei den meisten Tutorials ben\'f6tigte man einen 16MHZ Crystal, den wir aber nicht besa\'dfen und wir auch im Praktikumsraum keinen finden konnten.\par
\par
\par
\ul 07-Pololu AVR-Programmer:\par
\ulnone Das Problem jetzt war, dass wir einen Programmer brauchten, um den Chip zu programmieren, weil nun nicht mehr das Arduino als Programmer herhalten konnte. Im Praktikumsraum fanden wir dazu mehrere Pololu Avr Programmer. Der Pololu USB AVR-Programmer ist ein kompakter ISP (In-System Programmer) f\'fcr AVR Mikrocontroller. Der Programmer stellt ein Interface zur \'dcbertragung eines kompilierten AVR Programms vom PC zum Flash Speicher des Chips zur Verf\'fcgung. Nach schlau machen auf deren Seite, haben wir den Programmer an unserem Microcontroller angeschlossen.\par
\par
\ul 08-Atmel Studio und Tera Term:\par
\ulnone Neben Programmer verwendeten wir ab jetzt nun auch nicht mehr die Arduino IDE sondern suchten nach einer passenden Entwicklungsumgebung. Nach k\'fcrzeren Recherchen wurde uns Atmel Studio (ehemaliges AVR Studio) f\'fcr Windows empfohlen und so entschieden wir uns f\'fcr diese IDE. Bevor man mit Atmel Studio programmieren kann, muss man noch ein paar Anwendungen installieren. Dazu z\'e4hlt WinAVR. WinAVR enth\'e4lt neben dem C und C++ Compiler f\'fcr alle AVR Mikrocontroller und den erforderlichen Zusatzprogrammen, den sogenannten Binutils, noch einige andere Pakete, z. B. die Bibliotheken avr-libc oder avr-io, die Programmiersoftware AVRDUDE und den Editor Programmer's Notepad.\par
Atmel Studio besitzt leider keinen wirklich brauchbaren Seriellen Monitor, deshalb installierten wir uns die Software \ldblquote Tera Term\rdblquote  mit der wir die Ausgaben kontrollieren konnten. Tera Term ist ein kostenloser Terminal-Emulator, der einfach einzurichten ist. Beim starten des Terminals kann man den Port ausw\'e4hlen, dessen Ausgaben man anzeigen lassen will. Da der Pololu Programmer zwei Ports besitzt, konnten wir einen zum Programmieren und den anderen als Schnittstelle f\'fcr unseren seriellen Monitor benutzen.\fs24\par
\fs22\par
Wir dachten, dass unser Microcontroller jetzt auch mit Strom versogt war, da er ja durch dem Programmer an Vcc und Ground angeschlossen w\'e4re. Allerdings leuchtete die rote LED auf dem Pololu immer noch rot und wir gelangen nicht in den Programming-Mode.\par
Wir mussten uns daher um eine externe Stromversorgung k\'fcmmern. Die meiste Zeit arbeiteten wir zu Hause und konnten so nicht die Ger\'e4te im Praktikumsraum verwenden. Anstelle verwendeten wir den Elegoo Power MB v2 der auch bei dem Starter Kit mitgeliefert wurde. Mit diesem waren wir nun in Stande unseren Microcontroller mit 3,3 oder 5 Volt zu versorgen. Manchmal verwendeten wir auch das Elegoo Uno Board zur reinen Stromversorgung.\par
\par
Nun haben wir alles angeschlossen und konnten unser erstes C++ Programm auf den Chip laden. Wie beim Arduino war das ein einfacher Blink Sketch.\fs24\par
\page\ul\fs22 09-BlinkSketch:\ulnone\fs24\par
\fs22 Hier auf der Folie sieht man den Code f\'fcr den Sketch, mit dem wir eine LED zum Blinken bringen wollen. Im Gegensatz zum Arduino sieht es jetzt schon deutlich komplizierter aus. Da wir kein Arduino Framework zum Programmieren verwenden, konnten wir Methoden wie pinMode, digitalRead oder digitalWrite nicht verwenden. Deshalb haben wir eine Header Datei erstellt, welche wir importieren, in der wir die 3 Methoden selbst geschrieben haben, die die Arduin.h ersetzten sollen.\par
\ul\par
10-13-pinMode, usw.:\ulnone\fs24\par
\fs22 Auf diese m\'f6chte ich jetzt kurz eingehen.\fs24\par
\fs22 Mit der Methode PinMode kann man einen Pin als OUTPUT oder INPUT definieren. Um einen Pin als INPUT/OUTPUT zu definieren, muss man diesen im zust\'e4ndigen Register eintragen. DDRD verwendet man f\'fcr die Ports D, DDRB f\'fcr die Ports B. Um jetzt den Port D4 als Output einzutragen, schreibt man DDRD |= (1<<4). Um das jetzt erkl\'e4ren, nehmen wir an, dass das Register DDRD so aussieht. Der Ausdruck 1<<4 ist ein leftshift um 4 stellen. Als Startwert nehmen wir 00000001 und verschieben alle Bits um vier Stellen nach Links.  Damit erhalten wir 00010000. Diese Bitfolge verkn\'fcpft man mit dem \ldblquote oder\rdblquote  Operator und man erh\'e4lt diesen Ausdruck. Das vierte Bit ist nun eine 1, also ein Output. \fs24\par
\fs22 So ziemlich \'e4hnlich sieht es aus, wenn man einen Port als INPUT definieren m\'f6chte. Der Unterschied zwischen den 2 ist, dass man nun, nach dem leftshift, alle Bits negieren muss, und dann nicht mit einem Oder verkn\'fcpfen, sondern mit einem Und Operator. Bei diesem Beispiel hier m\'f6chte ich den Port2 als Input definieren. Wie man auf der Folie sehen kann, ist das zweite Bit nun eine 0, also ein Input.\fs24\par
\fs22 Die Methode digitalWrite ben\'f6tigt einen Pin und den Parameter High oder Low. Der Ausdruck f\'fcr High ist derselbe wie der, den man verwendet, wenn man einen Port als OUT bzw INPUT definieren will. Der Unterschied zur PinMode liegt darin, dass man nun das Port Register verwenden muss, anstatt des DDRD. Das Gleiche gilt f\'fcr LOW. \fs24\par
\fs22 DigitalRead bekommt als Parameter nur den Pin. Um zu \'fcberpr\'fcfen, ob der Input von Port 4 High ist, muss der Ausdruck PIND & (1<<4) true ergeben. F\'fcr Low logischerweise false. Zum Code. Nehmen wir an, PORT 4 ist HIGH. PIND besteht zum Beispiel aus der folgenden Bitfolge. Der leftshift ist wieder derselbe wie bei den Beispielen vorher. Nach dem Anwenden des Und Operators erhalten wir eine Bitfolge, die nicht 0 ergibt, also High. In unserem Beispiel haben wir 16 erhalten. Sollte der Port4 LOW sein, dann w\'fcrden wir 0 herausbekommen.\fs24\par
\fs22\par
\fs24\page\ul\fs22 14-Fehlerbehebung:FAB\ulnone\fs24\par
\fs22 Der LED-Sketch funktionierte nun. Der n\'e4chste Schritt war nun den Temperatursensor auch auf unserem Standalone-MCU zum Laufen zu bringen.\fs24\par
\fs22 In erster Linie verwenden wir den gleichen Code wir vorher bei dem Arduino. Das hei\'dft wir importierten dieselbe Library und kopierten auch den Code von der Main-Datei. Diesen zum Laufen zu bringen brachte jedoch in Hinblick auf den anderen Sketches zuvor mehrere Schwierigkeiten. Beim Compilieren des Codes traten viele Fehler auf. Da die Library f\'fcr Arduino bestimmt war, mussten wir noch ein paar Dinge anpassen. Zum Beispiel mussten wir den Datentyp Byte, den Arduino dauernd verwendet, selber hinzuf\'fcgen. F\'fcr pinMode, digitalRead und digitalWrite haben unsere, wie vorher angesprochenen, Methoden verwendet und wir mussten zus\'e4tzlich eine Library f\'fcr Strings einbinden, sodass es m\'f6glich war, den Code erfolgreich zu builden. Nach den Basteleien traten keine Fehler mehr bei der Compilierung des Codes auf. Beim hochladen auf den Chip allerdings funktionierte der Temperatursensor immer noch nicht. Den Wert, den der Sensor uns zuschickt, haben wir in Tera Term ausgeben lassen. Anstatt des Wertes f\'fcr die Temperatur/Luftfeuchtigkeit, wurden nur wei\'dfe K\'e4stchen ausgegeben. Der einzige Grund f\'fcr den Fehler lag nach unserer Meinung an dem Takt des Chips.\par
Wir haben uns entschlossen, statt dem internen Oszillator des Microcontrollers, der eine Taktrate von bis zu 8Mhz erreichen kann, auf einen externen Quarz mit denselben Mhz wie dem Arduino, also 16Mhz, umzusteigen. Zwar wird in mehreren Foren erw\'e4hnt, dass f\'fcr Sensoren wie einem Temperatur-Sensor der interne Oszillator leicht ausreichen m\'fcsste, aber wir versuchten es trotzdem.\par
Nach dem Einbauen des 16Mhz Quarz und dem Einstellen der Fuse-Bits bei den Programmer-Einstellungen lief nun auch der DHT11-Temperatursensor ohne Probleme, ohne den Code von vorher ver\'e4ndert zu haben.\par
Durch den externen Quarz muss der Microcontroller f\'fcr eine idealen Ablauf mit ca. 5 Volt versorgt werden und durch die erh\'f6hte Taktzahl steigt nochmals der Stromverbrauch. Wir versuchten somit nochmals unseren Sensor auch ohne externen Oszillator zum Laufen zu bringen.\par
\par
Schlussendlich lag das Problem an der Definition des F_CPUs. Wir haben ihn mit einer Geschwindigkeit von 8.000.000UL definiert, weil auch die meisten Codebeispielen im Internet UL f\'fcr (Unsigned Long) hinzugef\'fcgt hatten. Eher durch Zufall l\'f6schten wir die K\'fcrzel UL weck und es funktionierte endlich auch ohne externen Quarz und aus den mysteri\'f6sen K\'e4stchen wurde Temperatur und Luftfeuchtigkeit.\par
\par
\ul 15-Temperatur- und Luftfeuchtigkeitssensor:\par

\pard\nowidctlpar\hyphpar0\ulnone Nun genauere Informationen zu unserem Temperatur- und Luftfeuchtigkeitssensor:\par
Der DHT11 Sensor wird mit 3,3 \endash  5.5VDC versorgt. Bei unserem Microcontroller verwenden wir f\'fcr die Versorgung eine Spannung von 3,3 Volt.\fs24\par
\fs22 Ein Kommunikationsprozess zwischen MCU und Sensor dauert in etwa 4 ms.\fs24\par
\fs22 F\'fcr die Kommunikation und die Synchronisation zwischen dem MCU und dem Temperatursensor wird das Single-bus data format verwendet. Das hei\'dft zur \'dcbertragung dient allein 1 Kabel.\fs24\par
\fs22 Der Kommunikations-Prozess gestaltet sich wie folgt: Zu Beginn schickt der Microcontroller ein Start-Signal an den Sensor. Daraufhin schaltet der Sensor in den running-mode. Nun antwortet der Sensor mit einem Signal von 40-bit Daten, die vorher schon angesprochen wurden, und sobald die Daten \'fcbermittelt wurden geht der Sensor wieder in den low-power-consumption mode \'fcber.\par
\par
\ul 16-Kommunikationsprozess:\par
\ulnone Hier noch mal genauer:\par
Man sieht in dieser Abbildung noch einmal gut, dass der Single-Bus sowohl von MCU als auch vom Sensor verwendet wird und die Verwendung je nach Zeitpunkt im Prozess ver\'e4ndert wird.\par
\fs24\lang1033\par
\fs22\lang1031 Start Signal:\fs24\lang1033\par
\fs22\lang1031 Unser Programm setzt den Data Single-bus von high auf low, dieser Vorgang muss eine bestimmte Zeit dauern, sodass der Sensor unser Signal erh\'e4lt. Nun k\'f6nnen wir den Bus wieder auf high setzen und warten auf die Antwort des DHT.\fs24\par
\fs22\par
Sobald der Sensor das Start Signal erhalten hat passieren noch einige Start-Prozeduren. Wir k\'f6nnen dadurch nochmals feststellen ob f\'fcr die \'dcbertragung der Daten alles funktioniert, ansonsten wird die \'dcbertragung abgebrochen und ein Fehler zur\'fcckgegeben. Sind diese Prozeduren erfolgreich abgeschlossen beginnt nun der eigentliche Datenaustausch.\par
\par
\ul 17-Bit-\'dcbertragung:\par
\ulnone Jedes Bit wird folgenderma\'dfen \'fcbertragen:\par
Der Sensor beginnt mit einem 50us low-voltage-level, die L\'e4nge des darauffolgende high-voltage-level bestimmt dann den Wert 1 oder 0. Dauert das Signal zwischen 26-28us dann \'fcbertr\'e4gt der Sensor eine \ldblquote 0\rdblquote , hat das Signal eine L\'e4nge von 70us \'fcbertr\'e4gt er eine \ldblquote 1\rdblquote . Diese us werden hier in der for-Schleife gez\'e4hlt mit Hilfe von ticks je 10 us gez\'e4hlt. Waren es \'fcber 3 ticks, also eine 1, sind es weniger als 3 ticks eine 0.\par
Ist das 40. und letzte Bit \'fcbertragen folgt ein pull down des voltage level f\'fcr 50us. Danach geht der Single-Bus voltage zur\'fcck in den free status.\par
\par
Die confirm-Methode, die wir hier sehen, wird immer dann verwendet, wenn eine \'dcbertragung vom Sensor stattfindet, um zu \'fcberpr\'fcfen ob sie zu rechtm\'e4\'dfig abgelaufen ist. Im Laufe des Programms gibt es 6 Stellen wo bei Fehlern abgebrochen wird, um genauer zu identifizieren wo der Fehler gelegen hat. Das sieht man z.B: hier oder hier.\par
\par
\ul 18-parse-Methode:\par
\ulnone Nach der \'dcbertragung der 40 Bits m\'fcssen diese noch richtig geparsed werden, sodass sie auch im richtigen Format ausgegeben werden k\'f6nnen. Hier noch ein kurzer Einblick auf die zuvor angesprochene Checksumme. Alle Teil-Bytes werden addiert und \'fcberpr\'fcft ob sie mit dem letzten Byte \'fcbereinstimmen. Ist das der Fall, dann kann Temperatur und Luftfeuchtigkeit ausgegeben werden, ist das nicht so, dann hat sich ein \'dcbertragungsfehler ereignet und die \'dcbertragung war wertlos und muss wiederholt werden.\par
\par
\par
\par
\par
\uldb\par
\ulnone Da nun der Temperatur-Sensor verl\'e4sslich arbeitet, haben wir uns wieder dem CC1101 gewidmet. Zum Schluss gelang uns dort noch eine Kommunikation mit unserem Standalone Microcontroller und dem Arduino, wie am Anfang von Arduino zu Arduino.\fs24\par
\ul\fs22\par
Zum Abschluss ist zu sagen:\par
\ulnone Das Projekt bis jetzt hat uns allen drei sehr gut gefallen auch wenn es immer wieder zu frustrierenden Phasen gekommen ist. Uns fehlt es einfach an Grundverst\'e4ndnis bei diesen ganzen Sachen, von vor allem bei Hardware bezogenen Dingen, aber auch bei der Entwicklung mit C und gewissen Grundeinstellungen, die vorgenommen werden m\'fcssen bis der Microcontroller \'fcberhaupt l\'e4uft. Daher haben wir ziemlich viel Zeit in das Projekt investiert, ohne gro\'dfe Fortschritte zu machen. Weil jedes Mal beim Auftreten von kleinen Fehlern konnten wir diese nicht sofort beheben. Das Programmieren des Microcontrollers an sich fanden wir weniger schwierig. Wir haben in diesem Praktikum bis jetzt alle ziemlich viel dazugelernt und unsere Kenntnisse in diesem Bereich erweitert.\par
\par
\par
\ul GRE\par
\ulnone Aktuell sieht unser Microcontroller wie folgt aus:\par
\par
\par
Der DHT11-Sensor funktioniert nun, vielleicht werden wir unsere Wetterstation um einen weiteren Sensor erweitern.\par
Nat\'fcrlich m\'fcssen Details der \'dcbertragung noch mit dem Station-Team besprechen.\par
Stromversorgung unseres Microcontrollers muss noch gekl\'e4rt werden.\par
Und zum Schluss muss nach alles auf die Platine.\par
}
 